---
title: 'ConcorrÃªncia â‰  Paralelismo'
date: '2025-09-10'
lastmod: '2025-09-10'
tags: ['node', 'go', 'concorrencia', 'paralelismo']
draft: false
summary: 'Entenda a diferenÃ§a entre concorrÃªncia e paralelismo, como Go e Node lidam com isso, e pare de culpar o estagiÃ¡rio pelo gargalo errado.'
images: ['/static/images/twitter-card.png']
---

## Contexto

Sim, este Ã© um tÃ³pico bem teÃ³rico. Mas se vocÃª nÃ£o entender direito, vai acabar culpando o banco, o framework ou atÃ© o estagiÃ¡rio, quando na verdade o problema Ã© que vocÃª confundiu **concorrÃªncia com paralelismo**.

ConcorrÃªncia e paralelismo nÃ£o sÃ£o a mesma coisa.  
ConcorrÃªncia Ã© organizar vÃ¡rias tarefas ao mesmo tempo, mesmo que apenas uma esteja de fato executando em um dado instante.  
Paralelismo Ã© executar vÃ¡rias tarefas simultaneamente em diferentes nÃºcleos de CPU.

Imagine um chef picando legumes, mexendo a panela e conferindo o forno, alternando entre tarefas â€” isso Ã© concorrÃªncia.  
Agora imagine trÃªs chefs fazendo tudo ao mesmo tempo â€” isso Ã© paralelismo.

Sim, eu tenho assistido Master Chef demais ğŸ‘¨â€ğŸ³

<TOCInline toc={props.toc} exclude="IntroduÃ§Ã£o" />

## Go e Node

Em **Go**, temos goroutines. Elas sÃ£o como _green threads_: unidades leves de execuÃ§Ã£o criadas pelo runtime e multiplexadas sobre poucas threads reais do SO. TraduÃ§Ã£o: vocÃª pode criar milhares ou atÃ© milhÃµes de goroutines sem a sobrecarga maluca que teria se tentasse criar o mesmo nÃºmero de threads do SO.  
Detalhe importante: se vocÃª usar `net/http`, toda requisiÃ§Ã£o jÃ¡ recebe sua prÃ³pria goroutine automaticamente. ConcorrÃªncia vem de fÃ¡brica.

Em **Node**, as coisas sÃ£o um pouco diferentes. O runtime jÃ¡ lida muito bem com I/O pesado por meio do _event loop_, sem precisar de threads extras. Ã‰ por isso que vocÃª consegue atender um monte de requisiÃ§Ãµes simultÃ¢neas de API sem pensar em â€œcriar goroutinesâ€ â€” o modelo assÃ­ncrono do Node faz isso por vocÃª.  
Mas quando o problema Ã© CPU-bound (criptografia, compressÃ£o, cÃ¡lculos pesados), o event loop vira gargalo. AÃ­ entram os **Worker Threads**. Ao contrÃ¡rio das goroutines, eles sÃ£o threads reais do SO, cada um com sua prÃ³pria instÃ¢ncia do V8 e heap. Mais pesados, sim, mas resolvem quando vocÃª realmente precisa paralelizar tarefas custosas.

## Exemplos de cÃ³digo

### Go

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	go fmt.Println("running in goroutine") // executa concorrentemente
	fmt.Println("running in main")
	time.Sleep(time.Second) // espera a goroutine terminar
}
```

### Node

```js
// main.js
const { Worker } = require('node:worker_threads')

const worker = new Worker('./worker.js')
worker.on('message', (msg) => console.log(msg))

console.log('running in main')

// worker.js
const { parentPort } = require('node:worker_threads')
parentPort.postMessage('running in worker thread')
```

## ConclusÃ£o

- ConcorrÃªncia â‰  Paralelismo. VocÃª pode ter concorrÃªncia sem mÃºltiplos nÃºcleos.
- Go aposta em goroutines para lidar com I/O e tambÃ©m pode paralelizar tarefas de CPU quando necessÃ¡rio.
- Node aposta no event loop para I/O e em Worker Threads para trabalho pesado de CPU.

## ReferÃªncias

- [Worker Threads (Node, threads reais do SO)](https://nodejs.org/api/worker_threads)
- [Goroutines (Go, threads em nÃ­vel de usuÃ¡rio)](https://go.dev/doc/go_for_cpp_programmers)
- [net/http (Go, 1 goroutine por requisiÃ§Ã£o)](https://pkg.go.dev/net/http#Server.Serve)

No fim do dia, nÃ£o Ã© sobre memorizar nomes chiques â€” Ã© sobre entender como o runtime da sua linguagem lida com concorrÃªncia e quando vocÃª realmente precisa de paralelismo. Caso contrÃ¡rio, vocÃª vai perder horas â€œotimizandoâ€ onde nÃ£o importa e vai errar o gargalo real.

---

No prÃ³ximo post, vamos falar sobre paralelismo, processos, goroutines e worker threads (de novo), e clustering.
