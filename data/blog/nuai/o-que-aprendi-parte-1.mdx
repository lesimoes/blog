---
title: 'O que aprendi essa semana - Parte I?'
date: '2023-08-20'
lastmod: '2023-08-19'
tags: ['nuai']
draft: false
summary: 'Estimativas, Como era antes do React? e Componentizar grandes ou pequenos.'
images: ['/static/images/twitter-card.png']
---

## Cenário

Esse é o primeiro **"O que aprendi essa semana?"** e ele é particularmente especial pra mim porque foi a primeira vez que assumi um compromisso regular e estruturado de treinamento com o time da Nuai.

Confesso que acho que para esse primeiro encontro todos estavam esperando algo mais técnico, mais mão na massa, normal... Mostrar como fazer com código é bom, mas algumas vezes precisamos ter em mente os "porquês" antes de sair aplicando as coisas.

Ou seja, o "na prática" é bom, mas o "na teoria" é necessário também. Prática sem teoria é marretar, vencer pela tentativa e erro (desestruturada), a teoria é o que vai trazer os "porquês" e temperar a prática.

<TOCInline toc={props.toc} exclude="Introduction" />

## Estimativas

Estimativa é um chute com um pouco mais de precisão! E essa analogia com um chute é perfeita porque se um chute fosse sempre preciso um penalti seria sempre gol.

Mais importante do que ensinar várias técnicas de estimativa (entre elas cartas, búzios e borra do café), creio que é mais importante é guiar as pessoas a criarem o seu próprio modelo mental para estimar.

#### Como começar a estimar?

Simples, apenas começe! Aqui na Nuai estimamos por períodos de tempo. Sim, eu sei que isso é um sacrilégio segundo o livro do amarelo e vermelho, porém na minha experiência para quem está começando agora no mundo a forma mais simples, sem se perder com ferramentas lúdicas é simplesmente estimar por tempo.

Por exemplo, ao receber uma tarefa a pessoa pode "quebrar" seus dias em períodos, manha e tarde, as vezes ela tem a noção que as manhãs dela são mais curtas e menos focadas, diferente do período da tarde. Então um bom começo pode ser:

- Hoje pela manhã, vou entender as regras de negócio da tarefa ou qual "dor" ela irá resolver.
- Hoje pela tarde, vou começar a atacar essa tarefa, primeiro vou criar uma página nova pra exibir XPTO, possivelmente vou precisar analisar a API e banco de dados, huuum, isso é meio novo pra mim... Talvez eu agarre aqui.
- Amanha pela manhã, talvez eu tenha um entendimento maior da API e do banco ou vou chamar o fulano para me ajudar.
- Amanha pela tarde, aqui creio que já terei um conhecimento bom para atacar de fato essa tarefa... Talvez a partir dai eu precise de mais um dia inteiro para terminar. Então minha estimativa é de apróximadamente 3 dias.

#### Como melhorar

Uma vez estimado você precisa acompanhar essa estimativa, não com um olhar de deadline e entrega (claro que isso é importante), e mais com um olhar de aprendizado:

- Por que errei na estimativa?
- Errei para mais ou para menos?

E aqui vem um ponto importante, o racional é melhorar as estimativas e não acertar! Com isso em mente você percebe que errar pra mais, estimar 3 dias e entregar em 1 dia, também é um problema.

#### Pontos importantes

Essa não é a forma oficial ou a forma mais usada no mercado, porém é a forma que hoje eu acredito que prepara para as formas mais usadas, como quebrar a tarefa em P,M,G. Creio que outras técnicas funcionam quando a pessoa tem uma visão mais real do que é uma tarefa pequena, média ou grande, quando a pessoa sabe quando e como ela produz mais. Depois desse auto conhecimento a pessoa pode fazer os jogos lúdicos de estimativa com mais racionalidade.

#### Saber pedir ajuda é muito importante

Aqui na Nuai trabalhamos com equipes dedicação exclusiva para cada projeto, mas isso não implica ser o "lobo solitário programador", pelo contrário, quando se tem claro as estimativas é muito importante levantar a mão sempre que algo muito inesperado acontecer, desta forma podemos traçar um plano B.

## Como era antes do React?

Hoje é muito comum trabalhar com pessoas que começaram sua jornada em TI entre por volta de 2019, uma época onde alguns problemas do passado já haviam sido resolvidos e claro, novos problemas apareceram. Acho que por esse motivo vejo algumas "justificativas" sem sentido para "por que usar React?". Resolvi puxar esse tópico não pra falar "na minha época era mais difícil!", ou lançar uma visão irreal e saudosista do passado.

Lembre-se que a tônica desse papo foram "os porquês", e creio que entender os porquês pode abrir a cabeça pra entender melhor as coisas.

#### Qual problema o React se propôs a resolver?

Na época pré-React (e pré-Angular) existia um problema em especial sério no mundo javascript que era a falta de sincronia entre o DOM e a lógica feita no javascript. Em resumo era assim:

1. Busca alguma coisa no DOM ou carrega um dado inicial (data fetch)
2. Processa esse dado
3. Manda ele pro DOM

O problema aqui é que você tinha que "ficar lembrando" se você já tinha atualizado o DOM ou não. Essa sincronia era um problema e claro que algumas abordagens foram usadas na época, muitas delas criavam uma DSL (Domain Specific Language) HTML com super poderes e várias chaves para resolver esse problema.

Essa sincronia do DOM com o javascript foi a motivação do React e de outras abordagens. Esse é o porquê de "tantos estados", porque é como o React trata o problema. Uma consequência disso é, dado que agora temos o início e a atualização do DOM em um único fica comodo quebrar nossa UI em partes menores com lógica + UI.

Note que isso é uma consequêcia da abordagem e não o motivo em si. Por exemplo o Angular abordou o mesmo problema de uma forma um pouco diferente onde também reunia lógica + UI, mesmo que em módulos.

Com isso em mente temos que os estados são o que vão nortear um componente e não uma separação "visual" em fragmentos da UI.

## Separar em componentes

Componentes grandes são ruins, quebre seus componentes em componentes menores! Esse é o mantra da bolha dev linkediana. Algumas pessoas repetem isso sem questionarem suas implicações.

#### Por que os componentes grandes são ruins?

Aqui seria óbvio, mas vai abrir nossa cabeça pro próximo tópico. Componentes grandes são péssimos para manter porque:

- Fazem muita coisa então tem **vários motivos para mudar**
- São péssimos para testar, teste unitários se transforma em testes de integração

_Aqui me reservei a não super entrar no tópico **motivos pra mudança** e **responsabilidade única** mas de forma resumida parte da bolha reproduz de forma errada o que é responsabilidade única._

#### Quebrando componentes

A alternativa diretamente ótima para componentes grandes é quebra-los, e eu concordo com isso. O que quero levantar aqui é se de fato esses novos componentes **devem ser novos arquivos**.

Parece ser a resposta mais óbvia, um novo componente um novo arquivo, porém existe um perigo ai... Cada vez que você cria um novo arquivo sem pensar você pode estar espalhando ainda mais as dependencias por ai. Um componente que importa o _axios_ e é quebrado em três novos arquivos agora são três lugares diferentes onde o _axios_ é importado.

Imagine isso num projeto real, grande e sem nenhum critério para isolar dependencias.

#### Quebrando em componentes, não necessariamente em arquivos

Lembre-se, sincronia de estado > divisão visual da UI. Tendo isso em mente é possível perceber que sempre quando necessário podemos criar componentes dentro do mesmo arquivo.

- Esses componentes irão compartilhar as mesmas dependencias,
- Irão estar agrupados de uma forma lógica na estrutura de arquivos do projeto
- Terão estados independentes - usando bem diminui a complexidade

**Mas e a reutilização?!**

Sim, mas é a reutilização? Não temos! Mas antes pense em dois pontos:

- Você precisa reutilizar fora daquele contexto?
- Você sabe como criar um componente reutilizavel?

Logo na primeira pergunta uma resposta comum é "Pode ser que amanhã ou depois...", então amanhã ou depois você cria esse componente mágico.

Sobre a segunda um problema muito comum que vejo, principalmente pra quem tá ali entre o junior e pleno, é criar um componente que resolve todos os casos de uso possíveis e imagináveis da humanidade. A pessoa entra num limbo da oitava dimensão pra criar uma super abstração, tudo em nome da reutilização e não duplicação de código.

Bem, essa super abstração além de (muitas vezes) ser desnecessária leva a trechos de código cada vez mais específicos, fechados para mudança e pra extensão. Levam a lógicas complexas que demandam um grande esforço para mudança. E a minha experiência me diz que isso vira um legado, algo que ninguém que colocar a mão.

Nesse cenário a duplicação de código são códigos duplicados porém que não se metem a besta de resolver vários casos de uso, muitas vezes eles resolvem apenas um caso com pequenas mudanças, são componentes mais enxutos e simples.

Onde eu quero chegar com isso? **Duplicação de código é menos pior que abstração complexa**. Inclusive é uma solução temporária para substituir um componente super abstrato.

Uffa, foi isso! Vou deixar alguns links por aqui que vão complementar tudo isso.

[Documentário React](https://www.youtube.com/watch?v=8pDqJVdNa44)

[When to break up a component](https://kentcdodds.com/blog/when-to-break-up-a-component-into-multiple-components)

[Wrong abstraction](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction)
